package GraphFramework;

import java.util.*;

public class MHPrimAlg extends MSTAlgorithm {

    //---------------------------------------------------------------------------------------------
    // method that takes an `ArrayList` of `Vertex` objects as its input parameter. 
    // The method doesn't return anything, 
    // but instead updates the `isVisited` property of each vertex in the input list
    // to indicate whether it's included in the MST
    // and updates the `MSTResultList` and `totalCost` variables 
    // to store the edges and cost of the resulting MST
    public void prim(ArrayList<Vertex> vertices) {
        
        // ArrayList to store edges in a heap-like data structure.
        ArrayList<GraphFramework.Edge> minHeap = new ArrayList<>();

        // variable that stores the sum of weights of all edges in the MST
        int totalCost = 0;

        // choosing an arbitrary starting vertex (the first one in the input list),
        Vertex startVertex = vertices.get(0);
       
        // marking it as visited,
        startVertex.isVisited = true;

        // Add all adjacent edges of the start vertex to the min-heap
        for (GraphFramework.Edge edge : startVertex.adjLists) {
            minHeap.add(edge);
        }

        // sorting the edges according to their weights 
        // so that the edge with the smallest weight is always considered first in the algorithm.
        Collections.sort(minHeap, Comparator.comparingInt(edge -> edge.weight));
       
        // Building the MST untill it includes all the vertices 
        while (!minHeap.isEmpty()) {

            // Getting the edge with the minimum weight
            Edge currentEdge = minHeap.remove(0);

            // Checking if the target vertex of the edge has already been visited
            if (currentEdge.target.isVisited) {
                continue;
            }

            // ---- Otherwise  
            
            // Add the edge to the MSTResultList
            MSTResultList.add(currentEdge);
            
            // add its weight to the total cost 
            totalCost += currentEdge.weight;

           
            // Adding all adjacent edges of the target vertex to the `minHeap` if they haven't been visited yet 
            for (Edge edge : currentEdge.target.adjLists) {
                
                if (!edge.target.isVisited) {
                    minHeap.add(edge);
                }
            }

            // Update the target vertex as visited
            currentEdge.target.isVisited = true;

            // Resorting after adding the new edges 
            Collections.sort(minHeap, Comparator.comparingInt(edge -> edge.weight));
        }

        // calling the method that will print the results 
        displayResultingMST( MSTResultList);
    }

    //---------------------------------------------------------------------------------------------
    // method to diplay the MST information 
    // method that takes an `ArrayList` of `Edge` objects as its input parameter.
    // and an integer variable that stores the sum of weights of all edges in the MST
    // The method doesn't return anything, 
    // but instead print the information of the `MSTResultList` and `totalCost` variables 
    public void displayResultingMST( ArrayList<Edge> MSTResultList) {
        int totalCost = 0;
        System.out.println("The phone network (minimum spanning tree) generated by min-heap based Prim algorithm"
                + "is as follows:\n");

        // loop to go throuh the list that save the resulting edges 
        for (int i = 0; i < MSTResultList.size(); i++) {
            
            System.out.println("Office No." + MSTResultList.get(i).source.displayInfo() + " - Office No. " + MSTResultList.get(i).target.displayInfo()
                    + " : line length: " + MSTResultList.get(i).displayInfo());
        }
        
        System.out.println("Total cost: " + totalCost + "\n");

    }
}
